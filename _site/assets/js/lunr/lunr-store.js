var store = [{
        "title": "Ant Cheat Sheet",
        "excerpt":"This is a simple document introducing how to write the build.xml of Ant for your projects.Each Ant build.xml has a &lt;project&gt; element as the root element, this element can have a name attribute, which specify the name of this project; a basedir element, which determines the root path during the...","categories": [],
        "tags": ["project","tools"],
        "url": "https://pyemma.github.io/Ant-Cheat-Sheet/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "[Lintcode] Triangle Count",
        "excerpt":"Given an array of integers, how many three numbers can be found in the array, so that we can build an triangle whose three edges length is the three numbers that we find?The most naive solution is to enumerate all triples and then check if they can construct a triangle...","categories": [],
        "tags": ["algorithm","interview"],
        "url": "https://pyemma.github.io/Lintcode-Triangle-Count/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Simple Bloom Filter Implementation Part I",
        "excerpt":"Recently, I’m studying some basic concepts in distributed system. The materials I’m using is Distributed Systems Concepts. I know that simply reading the book is far not enough: the concepts are abstract, but we need to handle partical problem. So I decided to do some simple projects, using some existing...","categories": [],
        "tags": ["project","distributed system","data structure"],
        "url": "https://pyemma.github.io/Simple-Bloom-Filter-Implementation-Part-I/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Simple Bloom Filter Implementation Part 2",
        "excerpt":"IntroductionIn the last blog, we introduced the initial version of bloom filter. In the first implementation, we only tested our bloom filter on built in type String. This time, we tested in against a custom class Person. The idea is simple: we use thrift to define our custom data structure....","categories": [],
        "tags": ["project","distributed system","data structure"],
        "url": "https://pyemma.github.io/Simple-Bloom-Filter-Implementation-Part-2/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "[Hackerrank] Cut the tree",
        "excerpt":"The problem is available here. The idea is to use postorder traversal of the tree to enumerate each possible remove of edge, and return the sum of the sub-tree to its parent node. This problem represent the tree as a acyclic undirected graph, which is a quite wired representation.public class...","categories": [],
        "tags": ["algorithm","interview"],
        "url": "https://pyemma.github.io/Hackerrank-Cut-the-tree/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "[Lintcode] Count of Smaller Number before itself",
        "excerpt":"Give you an integer array (index from 0 to n-1, where n is the size of this array, value from 0 to 10000) . For each element Ai in the array, count the number of element before this element Ai is smaller than it and return count number array.In this...","categories": [],
        "tags": ["algorithm","interview"],
        "url": "https://pyemma.github.io/Lintcode-Count-of-Smaller-Number-before-itself/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "[Lintcode] Interval Sum II",
        "excerpt":"Given an integer array in the construct method, implement two methods query(start, end) and modify(index, value): For query(start, end), return the sum from index start to index end in the given array. For modify(index, value), modify the number in the given index to value public class Solution { private TreeNode...","categories": [],
        "tags": ["algorithm","interview"],
        "url": "https://pyemma.github.io/Lintcode-Interval-Sum-II/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "[CodeFights] NumberGameVI",
        "excerpt":"The problem is available here. A relatively straight forward game problem. If the current person want to win, the only requirement is that there exist a move can make B lose. And if there is no move can make B lose, then A will lose. Translate this into recursion and...","categories": [],
        "tags": ["algorithm","interview"],
        "url": "https://pyemma.github.io/CodeFights-NumberGameVI/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Design Pattern Summarization",
        "excerpt":"Design Pattern SummarizationStrategy PatternDefines a family of algorithms, encapsulate each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.[Image: file:///-/blob/eDDAAAJA4tZ/2DMfZKq387ZdSBlQHdKHXg]Use composition instead of inheritance to separate the detailed actions from the clients code. The detailed actions can be determined or changed in run...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Design-Pattern-Summarize/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Clean Code Summarize",
        "excerpt":"Here is just some tips I think is most useful for guiding me to write better code from book Clean Code: A Handbook of Agile Software Craftsmanship.##NamingWe cannot avoid naming things well we are writing code, a good name can considerably increase the readability of the code. We even does...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Clean-Code-Summarize/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Math Equation",
        "excerpt":"Use $$ to write math equation\\[\\sum_{n=1}^\\infty 1/n^2 = \\frac{\\pi^2}{6}\\]\\[\\textbf{A}\\textbf{B} = \\textbf{C}\\]Use \\begin{equation} to write math equation\\begin{equation}\\sum_{n=1}^\\infty 1/n^2 = \\frac{\\pi^2}{6}\\end{equation}\\[\\begin{align*} &amp; \\phi(x,y) = \\phi \\left(\\sum_{i=1}^n x_ie_i, \\sum_{j=1}^n y_je_j \\right) = \\sum_{i=1}^n \\sum_{j=1}^n x_i y_j \\phi(e_i, e_j) = \\\\ &amp; (x_1, \\ldots, x_n) \\left( \\begin{array}{ccc} \\phi(e_1, e_1) &amp; \\cdots &amp; \\phi(e_1, e_n)...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Math-Equation/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 1",
        "excerpt":"This is the first post for the series reinforcement learning. The main source for the entire series is here. The post mainly focus on summarizing the content introduced in the video and slides, as well as some of my own understanding. Any feedback is welcomed.In this post, we will talk...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Reinforcement-Learning-Lesson-1/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 2",
        "excerpt":"In the last post, we introduced the definition of Markov Decision Process and Bellman Equation. Now, if you are given the states \\( S \\), action $A$, transition matrix $P$, rewards $R$ and discounting ratio \\( \\gamma \\), how would you come up with a solution for this MDP? i.e....","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Reinforcement-Learning-Lesson-2/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 3",
        "excerpt":"In this lesson, we will learn about what to do when we have no knowledge about the MDP. In the last lesson, we learnt about how to solve a MDP when we have full information about it (e.g. $P$, $R$). When we don’t have enough information, the Bellman Equation won’t...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Reinforcement-Learning-Lession-3/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 4",
        "excerpt":"In this lecture, we learn how to solve an unknown MDP. In the last lecture, we introduced how to calculate the value function given a policy. In this one, we will try to find the optimize policy by ourselves.Mento Calro Policy IterationIn the Lesson 2, we mentioned how to solve...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Reinforcement-Learning-Lesson-4/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 5",
        "excerpt":"In this post, we are going to look into how can we solve the real world problem with a practical way. Think of the state value function $v(s)$ or the action value function $q(s, a)$ we mentioned before. If the problem has a really large state space, then it would...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Reinforcement-Learning-Lesson-5/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 6",
        "excerpt":"In the pervious we use a model to approximate the state value/action value function. In this post, we are going to learn how to directly parameterize a policy, which means we would directly get the probability of each action given a state:\\[\\pi_{\\theta}(s ,a) = P[a|s, \\theta]\\]In this case, we are...","categories": [],
        "tags": ["reinforcement learning"],
        "url": "https://pyemma.github.io/Reinforcment-Learning-Lesson-6/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 7",
        "excerpt":"In the pervious notes, we are all using model-free reinforcement learning method to find the solution for the problem. Today we are going to introduce method that directly learns from the experience and tries to understand the underlaying world.From Lesson 1 we know that a MDP can be represent by...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Reinforcement-Learning-Lesson-7/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "Reinforcement Learning Lesson 8",
        "excerpt":"This is the last lesson for the entire reinforcement learning, and in this lesson we will learn something related to exploit and explore. In machine learning service, like recommendation service, there is always a trade off between exploit and explore. Exploit means we are always choosing the best given the...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/Reinforcement-Learning-Lesson-8/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "DQN In Practice",
        "excerpt":"Recently I have been working on Deep-Q-Learning and apply it to some interesting AI games. In this post, I would like to give a brief introduction to how I implemented the Deep-Q-Learning, as well as lots of learning along the way.What is DQNTo understand DQN, we need first know is...","categories": [],
        "tags": [],
        "url": "https://pyemma.github.io/DQN-In-Practice/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "MIT Distributed System Course - MapReduce",
        "excerpt":"IntroductionThis is going to be a series of posts to record my learning of MIT 6.824 Distributed System. The post would focus on the course assignments which is to build some distributed systems from scratch using Go language. I would discuss some of the basic ideas that these assignments touched,...","categories": [],
        "tags": ["distributed system"],
        "url": "https://pyemma.github.io/Distributed-System-Map-Reduce/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "MIT Distributed System Course - Raft I",
        "excerpt":"IntroductionIn the following series of post, we are going to implement Raft consensus algorithm, which is used to manage replicated log. And on top of that, we would implement a failure tolerance key-value store. This type of failure tolerant system is called replicated state machine. Replicated state machine operates on...","categories": [],
        "tags": ["distributed system"],
        "url": "https://pyemma.github.io/Distributed-System-RAFT/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "MIT Distributed System Course - Raft II",
        "excerpt":"IntroductionIn this post, we continue our work on raft implementation. The focus of this post would be the second part of raft, which is the log replication, and snapshot to optimize the size of the log.Let’s first go through the high level logic of how log replica works in raft:...","categories": [],
        "tags": ["distributed system"],
        "url": "https://pyemma.github.io/Distributed-System-RAFT-II/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"},{
        "title": "投资小白学习读财报",
        "excerpt":"最近开始步入投资领域，打算在自己的博客里面也专门开一个版块。主要的目的一方面是做阶段性的总结，和大家交流学习；另一方面也是给自己的博客增加一些多样性，而不是单纯的技术性博客（根本没人读 TAT）。我的背景是纯粹的投资小白，属于那种连股票还有期权都分不清楚的那种24k纯投资小白，而且之前还一直不懈于搞投资。在老婆的劝（wei）说（xie）之下，终于开始尝试学习。我学习东西比较喜欢做主题性的学习，有点类似于主题阅读。通常我会找到一个主题（这个主题可能是听别人提到的，或者是在网站上偶然看到的一个主题），然后尽可能搜索相关的资料学习，最后整理一下要点。在这一篇博客里面，我就打算先介绍一下，自己最近在学习的关于阅读财报的一些要点。去哪里找财报找上市公司的财报信息有很多种的途径，在这里我介绍两种我使用过的方法： 第一种是去公司的官方网站，然后找带有investor字样的链接。以我最近在研究的Palantir这家公司来说，在他家的官网最底下，有一个 Investor Relations 的链接，如下图所示。来到新页面上之后可以找到一个叫做 Financials 的下拉选项单，在这里可以找到一个 Quartely Results 和 SEC Filing 的选项。一般我们小白读一读 Quartely Results 上的东西就可以啦：有精简版的财报，还有制作精美的 PPT 供你选择阅读。当然也可以看更加正式的财报比如 K10 年报什么的，但是那个100多页的文档读起来可真的不轻松呀。 第二中方法是使用 Yahoo Finance 网站。在搜索栏里面输入想要查询的公司的股票代码（PLTR)或者公司名字，然后我们在结果页面上能找到一个 Financials 的tab，如下图所示。在这里我们也能得到公司的财报信息。 怎么读财报财报一共有三个表格，分别是盈利表(income sheet)，资产负债表(balance sheet)和现金流表(cash flow sheet)。在看这些表的时候基本上要遵守下面的几样原则： 绝对值(absolute number)很重要，但是比例(ratio)同样很重要，甚至是更加的重要。 单纯看一年的数据不够劲儿，需要综合着看历年的数据，来观察趋势（导数啊同学们），以此来判断公司未来的发展前景。 单纯看一家公司的也还不够劲儿，需要跟同一行业的其他公司来比较，从而了解这家公司在行业内的数据是不是足够优秀。这三张表中，我个人感觉最有用的还是盈利表和资产负债表，现金流表我到现在也还没有研究透彻，所以也不敢说得太多。首先我们看看看盈利表，通过这张表我们可以知道这家公司运营的如何。首先可以看的是一家公司的营收(Revenue)。同时我们还可以看到支出(Cost of Revenue)，也就是相应的支出有多少。这两项相减，我们能得到公司的毛利润(Gross Profit)。同时我们还能从表上得到公司其他的一些operation cost，比如科研(R&amp;D)还有市场营销(Marketing)之类的。除此之外还有要交的税啥的。如果我们把这些cost也都从应收里面扣除的话，就得到了传说中的净利润(Net Profit)或者净亏损(Net Loss)。我们把毛利润还有净利润分别跟营收相除，就得到了毛利率(Gross Margin)跟净利率(Net Margin)。下面我们来看个例子，比较一下Facebook还有Snapchat这两家公司的状况。 Facebook Snapchat从上面的表格中我们可以看出，2020年全年Facebook的营收比2019年增长了大约21.59%，Snapchat则是38.16%。说明Snapchat的增长速度远远超过Facebook，这个也是比较符合我们的预期的，因为Facebook已经是一个大型的非常成熟的企业了，而Snapchat任然处于一个高速的发展阶段。这个从两家公司最后的净利润也可以看出来，Facebook是有实现盈利的，而Snapchat任然是处于亏损的状态。2020年Facebook的净利率大概是33.9%，相比较2019年的26.1%，有一个比较大的提升。这个对于科技公司来说在2020年是一个比较普遍的影响，由于疫情的影响，科技公司的业务往往实现了一个爆发式的增长。巴菲特老爷子就很看重公司的毛利率还有净利率，他的一个建议是，一个公司的毛利率在40%以上，净利率在20%以上的话，那么这个公司就是还蛮不错的。有了净利润，我们再除以全部的股东权益的话，那么就能得到每股收益(Earning Per Share)。这个不用我们自己手算，在盈利表中就已经给了。Facebook的EPS从2019年的6.48涨到了10.22，实现了57%的增长。EPS还有一个很重要的用途就是用来计算P/E值，这个值在价值投资里面是一个很重要的指标，用来衡量一家公司的股票是被高估还是低估了。在《聪明的投资者》一书中，作者就建议当P/E值超过40的时候，可以考虑卖出股票。这条建议在现在的成长股中可能不是很实用（P/E 超高的股票太多了）。Facebook的P/E值现在是26左右，Snapchat的则没有这个值，因为其EPS是负数（没有实现盈利）。不同的行业，其净利率，EPS可能会很不一样，这个是又行业本身的性质决定的。我们可以看一下苹果公司的数据，如下图所示 Apple苹果公司2020年的净利率是26%左右，比Facebook低了很多。其EPS从2019年的2.99增长到了2020年的3.31，实现了10.7%的增长。这些数据比Facebook低，但是这丝毫没有影响大家对其的喜爱。苹果公司的P/E值打到了32左右，说明投资者对于苹果公司的前景是更加看好的。这个例子就是想告诉大家，大家在比较公司的时候一定要同类别进行比较，否则数据没有什么意义（call...","categories": [],
        "tags": ["投资"],
        "url": "https://pyemma.github.io/Newbee-Learn-to-Read-Financial-Reports/",
        "teaser":"https://pyemma.github.io/assets/violet.jpg"}]
