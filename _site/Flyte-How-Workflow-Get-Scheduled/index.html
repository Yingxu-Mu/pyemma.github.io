<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.9.0 by Michael Rose
  Copyright 2013-2018 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE.txt
-->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>How Workflow Get Scheduled via Plugins in Flyte - Coding Monkey’s Blog</title>
<meta name="description" content="Reading open source code has been a recommended approach for software engineers to learn. However, in my past 8 years career, I didn’t do a good job on that. After working in a startup for 1 year, I accidentally foster the habit to read open source code XD. In this post, I would like to share one open source project I have been learning recently, and hope you would enjoy this journey as well.">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Coding Monkey's Blog">
<meta property="og:title" content="How Workflow Get Scheduled via Plugins in Flyte">
<meta property="og:url" content="https://pyemma.github.io/Flyte-How-Workflow-Get-Scheduled/">


  <meta property="og:description" content="Reading open source code has been a recommended approach for software engineers to learn. However, in my past 8 years career, I didn’t do a good job on that. After working in a startup for 1 year, I accidentally foster the habit to read open source code XD. In this post, I would like to share one open source project I have been learning recently, and hope you would enjoy this journey as well.">







  <meta property="article:published_time" content="2024-09-12T00:00:00-07:00">





  

  


<link rel="canonical" href="https://pyemma.github.io/Flyte-How-Workflow-Get-Scheduled/">







  <script type="application/ld+json">
    {
      "@context" : "http://schema.org",
      "@type" : "Person",
      "name" : "Bayarea Coding Monkey",
      "url" : "https://pyemma.github.io",
      "sameAs" : null
    }
  </script>







<!-- end _includes/seo.html -->

<script>
    MathJax = {
      tex: {
        inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]
      },
      svg: {
        fontCache: 'global'
      }
    };
    </script>
    <script
      type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<link href="https://pyemma.github.io/feed.xml" type="application/atom+xml" rel="alternate" title="Coding Monkey's Blog Feed">

<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="https://pyemma.github.io/assets/css/main.css">

<!--[if lte IE 9]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use http://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="https://pyemma.github.io/">Coding Monkey's Blog</a>
        <ul class="visible-links">
          
        </ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle Menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="http://schema.org/Person">

  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Bayarea Coding Monkey</h3>
    
    
      <p class="author__bio" itemprop="description">
        I am a coding monkey, and I am proud of it. I have done lots of work in machine learning area, especially recommendation system and AutoML. This blog summarize my journey to become an expert monkey in distributed system and LLM.
      </p>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="http://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Sunnyvale</span>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>


  <article class="page" itemscope itemtype="http://schema.org/CreativeWork">
    <meta itemprop="headline" content="How Workflow Get Scheduled via Plugins in Flyte">
    <meta itemprop="description" content="Reading open source code has been a recommended approach for software engineers to learn. However, in my past 8 years career, I didn’t do a good job on that. After working in a startup for 1 year, I accidentally foster the habit to read open source code XD. In this post, I would like to share one open source project I have been learning recently, and hope you would enjoy this journey as well.">
    <meta itemprop="datePublished" content="September 12, 2024">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 class="page__title" itemprop="headline">How Workflow Get Scheduled via Plugins in Flyte
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  10 minute read
</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On This Page</h4></header>
              <ul class="toc__menu">
  <li><a href="#problem">Problem</a></li>
  <li><a href="#high-level-architecture">High level architecture</a></li>
  <li><a href="#components-deep-dive">Components Deep Dive</a>
    <ul>
      <li><a href="#controller">Controller</a></li>
      <li><a href="#workerpoolworkqueue">WorkerPool/WorkQueue</a></li>
      <li><a href="#propellerhandler">PropellerHandler</a></li>
      <li><a href="#workflowexecutor">WorkflowExecutor</a></li>
      <li><a href="#nodeexecutor">NodeExecutor</a></li>
      <li><a href="#nodehandler">NodeHandler</a></li>
    </ul>
  </li>
  <li><a href="#summary">Summary</a></li>
</ul>
            </nav>
          </aside>
        
        <p>Reading open source code has been a recommended approach for software engineers to learn. However, in my past 8 years career, I didn’t do a good job on that. After working in a startup for 1 year, I accidentally foster the habit to read open source code XD. In this post, I would like to share one open source project I have been learning recently, and hope you would enjoy this journey as well.</p>

<p>I have been working in ML pipelining for a long time in Meta Ads. However, I didn’t have a comprehensive understanding across the entire stack, especially on how the underlying infra schedule the model training job and execute it over a fleet of machines. Recently, I have been exposed to an open source project: <a href="https://github.com/flyteorg/flyte">Flyte</a>, which is a orchestrator for ML pipeline built on top of Kubernetes. I think this might be a good opportunity for me to gain some deep understanding in this area.</p>

<p>I have always been a believer of “Learning by Doing”. My ultimate goal on learning this open source code is to implement a simplified version of ML pipeline orchestrator on my own. Next, let’s see what problem we are going to discuss in this post.</p>

<h2 id="problem">Problem</h2>

<p>In Flyte, we could use something called <code class="language-plaintext highlighter-rouge">Plugin</code> for distributed training, e.g. <a href="https://github.com/flyteorg/flyte/blob/master/flyteplugins/go/tasks/plugins/k8s/kfoperators/pytorch/pytorch.go">PyTorch Plugin</a>. In this post, we would discuss how these plugins are getting invoked, so that the distributed training job we defined could get executed. In this post, I would simplify the discussion and only laser eye on the main flow, for other important topics such as storage, pipeline definition and compilation, availability and scalability, I plan to defer it to later posts.</p>

<h2 id="high-level-architecture">High level architecture</h2>

<p><img src="/assets/flytepropeller_architecture.png" alt="FlytePropeller Design" /></p>

<p>The key component that is responsible for scheduling and monitoring the workflow in Flyte is called <code class="language-plaintext highlighter-rouge">FlytePropeller</code>. It tries to push <code class="language-plaintext highlighter-rouge">FlyteWorkflow</code>, which is defined as a <code class="language-plaintext highlighter-rouge">Custom Resource Definition</code> in k8s, to the desired state leveraging k8s reconcile mechanism. The official document of Flyte has provided a pretty good <a href="https://github.com/flyteorg/flyte/blob/d2614d416cd2565dc6a91f0ccff63f7a0dbdf970/docs/concepts/component_architecture/flytepropeller_architecture.rst">high level architecture</a> on <code class="language-plaintext highlighter-rouge">FlytePropeller</code>’s design, here is a list of the core components:</p>

<ul>
  <li><strong>Controller</strong>: overall brain of <code class="language-plaintext highlighter-rouge">FlytePropeller</code></li>
  <li><strong>WorkQueue/WorkerPoll</strong>: where worker lives and take jobs to do, a very classic design in job scheduling system</li>
  <li><strong>WorkflowExecutor</strong>: responsible for high-level workflow operations, such as tracking the status of workflow</li>
  <li><strong>NodeExecutor</strong>: responsible for process the node within the workflow and decide the action need to take</li>
  <li><strong>NodeHandler</strong>: different type of handler to execute different type of node in the workflow, e.g. TaskHandler for execute <code class="language-plaintext highlighter-rouge">Plugins</code> and WorkflowHandler to execute embedded sub-workflows</li>
</ul>

<p>Knowing what to do is one thing, and knowing how to do is another thing! Next, let’s jump into the code and see how these components are working internally and see how the logic defined within <code class="language-plaintext highlighter-rouge">Plugin</code> could be invoked.</p>

<h2 id="components-deep-dive">Components Deep Dive</h2>

<h3 id="controller">Controller</h3>

<p>Let’s get our journey starts with the <code class="language-plaintext highlighter-rouge">controller</code>. <code class="language-plaintext highlighter-rouge">Controller</code> is the starter for <code class="language-plaintext highlighter-rouge">FlytePropeller</code>, it is responsible for initializing other components:</p>

<ul>
  <li>In the <code class="language-plaintext highlighter-rouge">New</code> function of <code class="language-plaintext highlighter-rouge">controller</code>, we would create <code class="language-plaintext highlighter-rouge">workqueue</code> <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/controller.go#L422">here</a>.</li>
  <li>And then, we would create <code class="language-plaintext highlighter-rouge">workerpool</code> <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/controller.go#L461">here</a>. Note that <code class="language-plaintext highlighter-rouge">workerpool</code> requires the <code class="language-plaintext highlighter-rouge">workqueue</code> we have created before as part of its initialization (because worker needs to consume the jobs from the queue), and one <code class="language-plaintext highlighter-rouge">PropellerHandler</code>
    <ul>
      <li>notably, the <code class="language-plaintext highlighter-rouge">PropellerHandler</code> is <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/controller.go#L455">initialized with <code class="language-plaintext highlighter-rouge">WorkflowExecutor</code></a> and the <code class="language-plaintext highlighter-rouge">WorkflowExecutor</code> is <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/controller.go#L442-L455">composed of <code class="language-plaintext highlighter-rouge">NodeExecutor</code></a></li>
      <li><code class="language-plaintext highlighter-rouge">NodeExecutor</code> requires a <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/controller.go#L436"><code class="language-plaintext highlighter-rouge">nodeHandlerFactory</code></a> as part of the construction</li>
    </ul>
  </li>
</ul>

<p>As of now, all the key components we have mentioned in the high level architecture is ready. We would go deeper into them to understand how are they getting invoked.</p>

<p>Besides the <code class="language-plaintext highlighter-rouge">New</code> function, there is also a <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/controller.go#L106"><code class="language-plaintext highlighter-rouge">run</code></a> function which plays a critical role on launching the <code class="language-plaintext highlighter-rouge">controller</code>. It launches things such as the <code class="language-plaintext highlighter-rouge">workerpool</code>, <code class="language-plaintext highlighter-rouge">gc</code> and <code class="language-plaintext highlighter-rouge">metrics monitors</code>. <code class="language-plaintext highlighter-rouge">run</code> function is called within another function <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/controller.go#L93-L103"><code class="language-plaintext highlighter-rouge">Run</code></a>, in <code class="language-plaintext highlighter-rouge">Run</code>, one interesting part is that it is going to leverage the <strong>leader election</strong> functionality provided by k8s and only let leader to trigger <code class="language-plaintext highlighter-rouge">run</code> function. We would discuss this topic more in details in a future post.</p>

<p>As the <code class="language-plaintext highlighter-rouge">controller</code> would launch <code class="language-plaintext highlighter-rouge">workerpool</code>, let’s then move our view to <code class="language-plaintext highlighter-rouge">workerpool</code> and <code class="language-plaintext highlighter-rouge">workqueue</code> to understand how these 2 components work.</p>

<h3 id="workerpoolworkqueue">WorkerPool/WorkQueue</h3>

<p>The <code class="language-plaintext highlighter-rouge">workerpool</code> essentially is composed of <code class="language-plaintext highlighter-rouge">workqueue</code> and several <code class="language-plaintext highlighter-rouge">workers</code>, each are actually goroutines (this is also why Flyte could be pretty scalable on a single CPU, we would discuss this in the future). The <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/workers.go#L128"><code class="language-plaintext highlighter-rouge">Run</code> function</a> in <code class="language-plaintext highlighter-rouge">workerpool</code> is the most critical function, which is the one get invoked by <code class="language-plaintext highlighter-rouge">controller</code>. The main logic is the <code class="language-plaintext highlighter-rouge">for loop</code> <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/workers.go#L144-L153">here</a>, where we launch multiple goroutines and each goroutine would make a call to <code class="language-plaintext highlighter-rouge">runWorker</code> function. The <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/workers.go#L113"><code class="language-plaintext highlighter-rouge">runWorker</code></a> function is relatively simple, just an endless while loop to call <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/workers.go#L42"><code class="language-plaintext highlighter-rouge">processNextWorkItem</code></a> function. <code class="language-plaintext highlighter-rouge">processNextWorkItem</code> function gets an item from the <code class="language-plaintext highlighter-rouge">workqueue</code> and then <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/workers.go#L89">invokes the <code class="language-plaintext highlighter-rouge">PropellerHandler</code></a> we perviously passed in during initialization. As we could see, the key processing logic resides within <code class="language-plaintext highlighter-rouge">PropellerHandler</code>’s <code class="language-plaintext highlighter-rouge">Handle</code> function, which is defined as part of the interface <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/workers.go#L18-L23">here</a>, then let’s move on and see how this <code class="language-plaintext highlighter-rouge">Handle</code> works.</p>

<h3 id="propellerhandler">PropellerHandler</h3>

<p>The <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/handler.go#L180"><code class="language-plaintext highlighter-rouge">Handle</code> function</a> defined by the <code class="language-plaintext highlighter-rouge">Propeller</code> struct is the entry point of the reconcile process (Here <code class="language-plaintext highlighter-rouge">Propeller</code> has implemented the <code class="language-plaintext highlighter-rouge">Handle</code> interface, thus it could be considered as type <code class="language-plaintext highlighter-rouge">Handler</code> although there is no explicit inherit, this is how interface implementation works in Golang). The key logic is within this <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/handler.go#L240-L249">for loop</a>, where we call <code class="language-plaintext highlighter-rouge">streak</code> function up to a max trial. The <code class="language-plaintext highlighter-rouge">streak</code> function would try to do a single mutation to workflow, and return the mutated workflow upon succeed, otherwise no update made if failed. The workflow here is the CRD <code class="language-plaintext highlighter-rouge">FlyteWorkflow</code> and the mutation operation is done via <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/handler.go#L298"><code class="language-plaintext highlighter-rouge">TryMutateWorkflow</code></a>. <code class="language-plaintext highlighter-rouge">TryMutateWorkflow</code>  makes calls to <code class="language-plaintext highlighter-rouge">workflowExecutor</code>’s <code class="language-plaintext highlighter-rouge">HandleFlyteWorkflow</code> function to see if we could reconcile the workflow towards it desired status. We left out other details, such as how to handle failure, how to handle aborted workflow etc. From the code in <code class="language-plaintext highlighter-rouge">PropellerHandler</code>, we could observer that the <code class="language-plaintext highlighter-rouge">Handler</code> is just doing some high-level logic and the actual workflow processing logic is delegated to <code class="language-plaintext highlighter-rouge">workflowExecutor</code>. Now, let’s move to <code class="language-plaintext highlighter-rouge">workflowExecutor</code>.</p>

<h3 id="workflowexecutor">WorkflowExecutor</h3>

<p>The <code class="language-plaintext highlighter-rouge">HandleFlyteWorkflow</code> function called within <code class="language-plaintext highlighter-rouge">PropellerHandler</code> is a router function. It invokes other actual logic function based on the status of the workflow. For example, if the workflow status is in <code class="language-plaintext highlighter-rouge">WorkflowPhaseRunning</code>, then it would invoke <code class="language-plaintext highlighter-rouge">handleRunningWorkflow</code> function. In these functions, a common pattern is that they would setup the context, invoke <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/workflow/executor.go#L175"><code class="language-plaintext highlighter-rouge">nodeExecutor</code>’s <code class="language-plaintext highlighter-rouge">RecursiveNodeHandler</code> function to get the new status</a> and then update the status. The new status is passed back and used to transit the workflow’s status (which is the reconcile process). Notice that the <code class="language-plaintext highlighter-rouge">FlyteWorkflow</code> is passed as parameters for <code class="language-plaintext highlighter-rouge">executors.DAGStructure</code> and <code class="language-plaintext highlighter-rouge">executors.NodeLookup</code>, as well as the <code class="language-plaintext highlighter-rouge">startNode</code>.</p>

<p>There is some different operation based on the new status <code class="language-plaintext highlighter-rouge">RecursiveNodeHandler</code> passed back. For example, if the new status is partial completed, then the workflow would be enqueue again and return <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/workflow/executor.go#L194-L197">running status</a>.</p>

<p>The <code class="language-plaintext highlighter-rouge">WorkflowExecutor</code> handles the operation of workflow and decided what action to take. In ML pipeline, we know that workflow is usually composed by several nodes, and these nodes encapsulate the actual computation. Let’s take a look at <code class="language-plaintext highlighter-rouge">nodeExecutor</code>, which is responsible for handling this part.</p>

<h3 id="nodeexecutor">NodeExecutor</h3>

<p>The <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/nodes/executor.go#L177"><code class="language-plaintext highlighter-rouge">RecursiveNodeHandler</code> function</a> is one of the most important function in <code class="language-plaintext highlighter-rouge">NodeExecutor</code>. It is the entry point to execute a node within a workflow. It uses actor model and modified version of DFS to traverse the DAG and to execute non-blocked nodes. Based on different status queried based on the starter node passed from input, it applies different logic to proceed. For example, if the node status is already succeed, skipped or recovered, then it would invoke <code class="language-plaintext highlighter-rouge">handleDownstream</code> function; while if the node is in status that could be handled, then the key logic happens <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/nodes/executor.go#L229-L234">here</a>: first, based on the node’s kind, a dedicated handler is retrieved from <code class="language-plaintext highlighter-rouge">nodeHandlerFactory</code>; then <code class="language-plaintext highlighter-rouge">HandleNode</code> function would be invoked to execute the node.</p>

<p>The <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/nodes/executor.go#L266"><code class="language-plaintext highlighter-rouge">handleDownstream</code></a> is where the aforementioned <em>modified DFS</em> implemented. The <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/nodes/executor.go#L269-L300">logic</a> is relatively straightforward: starting from the input node, we retrieve all downstream nodes; then we iterate each node and invoke the <code class="language-plaintext highlighter-rouge">RecursiveNodeHandler</code> function on each of them, with self as the new input start node; keep the status to check if all downstream nodes have been processed, and return the status accordingly.</p>

<p>The <code class="language-plaintext highlighter-rouge">HandleNode</code> function of <code class="language-plaintext highlighter-rouge">nodeExecutor</code> is also a router function, where different processing function is invoked based on the status of the current node. The most important functions are <code class="language-plaintext highlighter-rouge">handleQueuedOrRunningNode</code> and <code class="language-plaintext highlighter-rouge">handleNotYetStartedNode</code>:</p>

<ul>
  <li>In the <a href="https://github.com/flyteorg/flyte/blob/96bbf7ed5331f7d629763a3721e90a1e35215da9/flytepropeller/pkg/controller/nodes/executor.go#L941"><code class="language-plaintext highlighter-rouge">handleNotYetStartedNode</code></a>, the most critic logic is the call to <code class="language-plaintext highlighter-rouge">preExecute</code>, where we check if the node could be queued to be further processed. The checking logic is relative simple, where we check the upstream nodes are all in succeed status or not</li>
  <li>In the <code class="language-plaintext highlighter-rouge">handleQueuedOrRunningNode</code>, we would first try to check if there are cached result given the current handler, and <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/executor.go#L1132">trigger the <code class="language-plaintext highlighter-rouge">execute</code> function</a> if there is no cache hit. The core part of the <code class="language-plaintext highlighter-rouge">execute</code> function is to <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/executor.go#L828">trigger the <code class="language-plaintext highlighter-rouge">Handle</code></a> function of the input <code class="language-plaintext highlighter-rouge">NodeHandler</code>, which is obtained from <code class="language-plaintext highlighter-rouge">RecursiveNodeHandler</code> and passed along the stack <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/executor.go#L229">here</a>, what a long journey!</li>
</ul>

<p>Now, we have hit the most underground part of <code class="language-plaintext highlighter-rouge">FlytePropeller</code>’s architecture. Next, we need to dive into <code class="language-plaintext highlighter-rouge">NodeHandler</code> to understand how the <code class="language-plaintext highlighter-rouge">Handle</code> function is implemented (here we would focus on how the handler used to fulfill the operations we need in distributed training).</p>

<h3 id="nodehandler">NodeHandler</h3>

<p>From the section above, we know that we retrieve node handler from <code class="language-plaintext highlighter-rouge">nodeHandlerFactory</code> in <code class="language-plaintext highlighter-rouge">RecursiveNodeHandler</code>, through the <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/factory/handler_factory.go#L43"><code class="language-plaintext highlighter-rouge">GetHandler</code> function</a>. Here is a step by step explanation on how we trigger the logic defined within plugins:</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">GetHandler</code> function returns node handler based on the type of the node. Most of training job is defined via <code class="language-plaintext highlighter-rouge">@task</code>, which is of <code class="language-plaintext highlighter-rouge">Task</code> type in Flyte</li>
  <li><a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/factory/handler_factory.go#L64">Here</a> is the setup of the node handler for <code class="language-plaintext highlighter-rouge">Task</code> type. In Flyte, all <code class="language-plaintext highlighter-rouge">Task</code> is treated as a <code class="language-plaintext highlighter-rouge">dynamic</code> node and handle through <code class="language-plaintext highlighter-rouge">dynamic</code> node handler. However, we would still <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/factory/handler_factory.go#L52">pass a <code class="language-plaintext highlighter-rouge">task</code> node handler into <code class="language-plaintext highlighter-rouge">dynamic</code> node handler</a></li>
  <li>In <code class="language-plaintext highlighter-rouge">dynamic</code> node handler’s <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/dynamic/handler.go#L175"><code class="language-plaintext highlighter-rouge">Handle</code> function</a>, by default, we would make a call to <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/dynamic/handler.go#L62"><code class="language-plaintext highlighter-rouge">handleParentNode</code></a>, and in this function, we would make a call to <code class="language-plaintext highlighter-rouge">TaskNodeHandler</code> interface’s <code class="language-plaintext highlighter-rouge">Handle</code> function</li>
  <li>The logic of <code class="language-plaintext highlighter-rouge">task</code> node handler’s <code class="language-plaintext highlighter-rouge">Handle</code> function is pretty complex. First, it tries to <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/task/handler.go#L537">find the <code class="language-plaintext highlighter-rouge">Plugin</code> based on <code class="language-plaintext highlighter-rouge">task</code> type</a>; then if there is no cache hit on result, it would <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/task/handler.go#L583">invoke plugin</a>
    <ul>
      <li>Within <code class="language-plaintext highlighter-rouge">invokePlugin</code> function, the core part is to <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/task/handler.go#L397">invoke the <code class="language-plaintext highlighter-rouge">Handle</code> function</a></li>
      <li><code class="language-plaintext highlighter-rouge">ResolvePlugin</code> search plugins through <code class="language-plaintext highlighter-rouge">pluginsForType</code>, where we initialized within the <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/task/handler.go#L280"><code class="language-plaintext highlighter-rouge">Setup</code> function</a>; the initialization is essentially sweeping the <code class="language-plaintext highlighter-rouge">enabledPlugins</code>, and we get it from <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/task/handler.go#L233"><code class="language-plaintext highlighter-rouge">WranglePluginsAndGenerateFinalList</code></a></li>
    </ul>
  </li>
  <li>In <code class="language-plaintext highlighter-rouge">WranglePluginsAndGenerateFinalList</code> function, we get all plugins related to k8s through <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/task/plugin_config.go#L56"><code class="language-plaintext highlighter-rouge">PluginRegistryIface</code> interface</a>; in <code class="language-plaintext highlighter-rouge">task</code> node handler, there is a data member <code class="language-plaintext highlighter-rouge">pluginRegistry</code> of this type, and the construction is <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/task/handler.go#L912">here</a>, where we call the <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flyteplugins/go/tasks/pluginmachinery/registry.go#L23"><code class="language-plaintext highlighter-rouge">PluginRegistry</code> function</a> from <code class="language-plaintext highlighter-rouge">pluginMachinery</code> module</li>
  <li>For each k8s plugin, <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/task/plugin_config.go#L56-L72">they would be wrapped within a <code class="language-plaintext highlighter-rouge">PluginEntry</code></a>, which is further <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/task/plugin_config.go#L68">wrapped in an object called <code class="language-plaintext highlighter-rouge">NewPluginManagerWithBackOff</code></a></li>
  <li>All k8s plugin would use the <code class="language-plaintext highlighter-rouge">RegisterK8sPlugin</code> function within the module <code class="language-plaintext highlighter-rouge">pluginmachinery.register</code> to register them into the system. For example, the Pytorch Plugin is registered <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flyteplugins/go/tasks/plugins/k8s/kfoperators/pytorch/pytorch.go#L223">here</a>. However, all of these plugins actual do not provide a <code class="language-plaintext highlighter-rouge">Handle</code> function, which should be called by the node handler. What happened?</li>
  <li>Actually, the <code class="language-plaintext highlighter-rouge">Handle</code> function is implemented within <code class="language-plaintext highlighter-rouge">PluginManager</code>. Since <code class="language-plaintext highlighter-rouge">PluginManager</code> <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flyteplugins/go/tasks/pluginmachinery/core/plugin.go#L45">implement all interface defined in <code class="language-plaintext highlighter-rouge">pluginCore.plugin</code></a>, we could treat <code class="language-plaintext highlighter-rouge">PluginManager</code> as a plugin to invoke (this is a class <strong>Strategy</strong> design pattern, where <code class="language-plaintext highlighter-rouge">PluginManager</code> defines the main logic and expressed via several step functions. And we could use composition to fulfill these step functions with different implementation)</li>
  <li>Within the <code class="language-plaintext highlighter-rouge">Handle</code> function in <code class="language-plaintext highlighter-rouge">PluginManager</code>, we would check the current status, if the status is not started, then we would call <code class="language-plaintext highlighter-rouge">launchResource</code>, otherwise we would call <code class="language-plaintext highlighter-rouge">getResource</code> and <code class="language-plaintext highlighter-rouge">checkResourcePhase</code> to obtain new transition information
    <ul>
      <li>In <code class="language-plaintext highlighter-rouge">launchResource</code> function, we would call <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/task/k8s/plugin_manager.go#L199"><code class="language-plaintext highlighter-rouge">BuildResource</code></a> function which is defined in the plugin. This function is used to <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flyteplugins/go/tasks/plugins/k8s/kfoperators/pytorch/pytorch.go#L133-L139">construct a kubeflow job</a>. Then it <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/task/k8s/plugin_manager.go#L220">make a <code class="language-plaintext highlighter-rouge">create</code> request via <code class="language-plaintext highlighter-rouge">kubeClient</code></a> to create this resource</li>
      <li>In <code class="language-plaintext highlighter-rouge">checkResourcePhase</code>, we would <a href="https://github.com/flyteorg/flyte/blob/7d59f106db997ab22686b1b414228fe323934c48/flytepropeller/pkg/controller/nodes/task/k8s/plugin_manager.go#L283">call <code class="language-plaintext highlighter-rouge">GetTaskPhase</code></a> to get the current status of the job</li>
      <li>Here is the point where Flyte is leveraging kubeflow and k8s to request resource and start the training job; both kubeflow and k8s would be huge topics, and I plan to discuss more in details in separate blog</li>
    </ul>
  </li>
</ul>

<p>Here, we reach the end of our journey and the remaining job is delegated to k8s. What a complex flow!</p>

<h2 id="summary">Summary</h2>

<p>In this post, we focus our discussion on how Flyte would invoke the distributed training job which is defined through plugin, we could see some common practice that is adopted in the design, such as utilization of queue and multithreading for scalability; separation of workflow executor and node executor for single responsibility principle; factory design for extensibility, etc.</p>

<p>In next topic, we would focus on the storage used in Flyte, which is also another critical component, as we need to store the status of the workflow, node and even intermediate result; as well as leveraging caching to speed up the execution by avoiding duplicated computation. Once we have a better understanding on the storage part, we could start to evaluate the availability, scalability and persistence of Flyte.</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="https://pyemma.github.io/tags/#distributed-system" class="page__taxonomy-item" rel="tag">distributed system</a><span class="sep">, </span>
    
      
      
      <a href="https://pyemma.github.io/tags/#job-scheduler" class="page__taxonomy-item" rel="tag">job scheduler</a><span class="sep">, </span>
    
      
      
      <a href="https://pyemma.github.io/tags/#open-source" class="page__taxonomy-item" rel="tag">open source</a>
    
    </span>
  </p>




        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2024-09-12T00:00:00-07:00">September 12, 2024</time></p>
        
      </footer>

      
  <nav class="pagination">
    
      <a href="https://pyemma.github.io/LLM-LLM-Training-101/" class="pagination--pager" title="LLM Training 101
">Previous</a>
    
    
      <a href="#" class="pagination--pager disabled">Next</a>
    
  </nav>

    </div>

    
  </article>

  
</div>

    </div>

    

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    
    
    
    
    
    
    <li><a href="https://pyemma.github.io/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2024 Bayarea Coding Monkey. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="https://pyemma.github.io/assets/js/main.min.js"></script>
  <script src="https://use.fontawesome.com/releases/v5.0.2/js/all.js"></script>







    
  <script>
    var disqus_config = function () {
      this.page.url = "https://pyemma.github.io/Flyte-How-Workflow-Get-Scheduled/";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "/[Flyte]-How-Workflow-Get-Scheduled"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://pyemma.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  



  </body>
</html>
